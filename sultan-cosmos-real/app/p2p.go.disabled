package app

import (
    "context"
    "fmt"
    "net"
    "time"

    "github.com/cometbft/cometbft/p2p"
    "github.com/cometbft/cometbft/p2p/conn"
    "github.com/cosmos/cosmos-sdk/client"
    "github.com/libp2p/go-libp2p"
    "github.com/libp2p/go-libp2p/core/host"
    "github.com/libp2p/go-libp2p/core/peer"
    "github.com/libp2p/go-libp2p/p2p/protocol/ping"
    "github.com/multiformats/go-multiaddr"
)

// P2PManager handles real P2P networking
type P2PManager struct {
    host      host.Host
    ctx       context.Context
    cancel    context.CancelFunc
    peers     []peer.ID
    pingServ  *ping.PingService
}

// NewP2PManager creates a new P2P manager with libp2p
func NewP2PManager(listenAddr string) (*P2PManager, error) {
    ctx, cancel := context.WithCancel(context.Background())
    
    // Parse listen address
    addr, err := multiaddr.NewMultiaddr(listenAddr)
    if err != nil {
        return nil, fmt.Errorf("invalid multiaddr: %w", err)
    }
    
    // Create libp2p host with real P2P
    host, err := libp2p.New(
        libp2p.ListenAddrs(addr),
        libp2p.EnableNATService(),
        libp2p.EnableAutoRelay(),
    )
    if err != nil {
        return nil, fmt.Errorf("failed to create libp2p host: %w", err)
    }
    
    // Create ping service for testing connectivity
    pingService := ping.NewPingService(host)
    
    return &P2PManager{
        host:     host,
        ctx:      ctx,
        cancel:   cancel,
        peers:    make([]peer.ID, 0),
        pingServ: &pingService,
    }, nil
}

// Start begins P2P networking
func (pm *P2PManager) Start() error {
    fmt.Printf("P2P Node started with ID: %s\n", pm.host.ID())
    fmt.Println("Listening on:")
    for _, addr := range pm.host.Addrs() {
        fmt.Printf("  %s/p2p/%s\n", addr, pm.host.ID())
    }
    return nil
}

// ConnectToPeer connects to a remote peer
func (pm *P2PManager) ConnectToPeer(peerAddr string) error {
    maddr, err := multiaddr.NewMultiaddr(peerAddr)
    if err != nil {
        return err
    }
    
    peerInfo, err := peer.AddrInfoFromP2pAddr(maddr)
    if err != nil {
        return err
    }
    
    if err := pm.host.Connect(pm.ctx, *peerInfo); err != nil {
        return err
    }
    
    pm.peers = append(pm.peers, peerInfo.ID)
    fmt.Printf("Connected to peer: %s\n", peerInfo.ID)
    return nil
}

// GetConnectedPeers returns list of connected peers
func (pm *P2PManager) GetConnectedPeers() []peer.ID {
    return pm.host.Network().Peers()
}

// Stop shuts down P2P
func (pm *P2PManager) Stop() error {
    pm.cancel()
    return pm.host.Close()
}

// CometBFT P2P compatibility layer
func SetupCometBFTP2P(nodeKey *p2p.NodeKey, listenAddr string) (*p2p.Switch, error) {
    // Create MConnection config
    mConfig := conn.DefaultMConnConfig()
    mConfig.SendRate = 5120000 // 5 MB/s
    mConfig.RecvRate = 5120000 // 5 MB/s
    
    // Create P2P config
    config := p2p.DefaultConfig()
    config.ListenAddress = listenAddr
    config.MaxNumInboundPeers = 40
    config.MaxNumOutboundPeers = 10
    
    // Create transport
    transport := p2p.NewMultiplexTransport(nodeKey, mConfig)
    
    // Create switch
    sw := p2p.NewSwitch(config, transport)
    
    return sw, nil
}
