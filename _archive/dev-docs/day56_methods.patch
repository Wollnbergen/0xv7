
// ===== DAY 5-6: TOKEN ECONOMICS METHODS =====

fn token_transfer(params: Params, meta: RpcMeta) -> Result<Value, RpcError> {
    RPC_CALLS.inc();
    let client_id = require_auth(&meta, "token_transfer")?;
    
    if !check_rate_limit("token_transfer", &client_id) {
        return Err(RpcError::invalid_request("Rate limit exceeded"));
    }

    let params_vec: Vec<serde_json::Value> = params.parse()
        .map_err(|_| RpcError::invalid_params("Invalid parameters"))?;
    
    if params_vec.len() < 3 {
        return Err(RpcError::invalid_params("Expected [from, to, amount, memo?]"));
    }
    
    let from = params_vec[0].as_str()
        .ok_or_else(|| RpcError::invalid_params("'from' must be string"))?;
    let to = params_vec[1].as_str()
        .ok_or_else(|| RpcError::invalid_params("'to' must be string"))?;
    let amount = params_vec[2].as_u64()
        .ok_or_else(|| RpcError::invalid_params("'amount' must be number"))?;
    let memo = params_vec.get(3).and_then(|v| v.as_str()).map(|s| s.to_string());

    let manager = crate::token_transfer::TransferManager::new(DATABASE.clone());
    
    match manager.transfer(from, to, amount, memo) {
        Ok(transfer) => {
            info!("Transfer: {} -> {} amount: {}", from, to, amount);
            Ok(json!({
                "id": transfer.id,
                "from": transfer.from,
                "to": transfer.to,
                "amount": transfer.amount,
                "status": "completed"
            }))
        }
        Err(e) => Err(RpcError::invalid_request(&e.to_string()))
    }
}

fn calculate_rewards(params: Params, meta: RpcMeta) -> Result<Value, RpcError> {
    RPC_CALLS.inc();
    let client_id = require_auth(&meta, "calculate_rewards")?;
    
    if !check_rate_limit("calculate_rewards", &client_id) {
        return Err(RpcError::invalid_request("Rate limit exceeded"));
    }

    let (address,) = params.parse::<(String,)>()
        .map_err(|_| RpcError::invalid_params("Expected [address]"))?;

    let manager = crate::rewards::RewardManager::new(DATABASE.clone());
    
    match manager.calculate_rewards(&address) {
        Ok(calc) => Ok(json!({
            "address": calc.address,
            "staked_amount": calc.staked_amount,
            "reward_amount": calc.reward_amount,
            "apy_rate": format!("{:.2}%", calc.apy_rate * 100.0),
            "staking_days": calc.staking_duration_days
        })),
        Err(e) => Err(RpcError::invalid_request(&e.to_string()))
    }
}

fn claim_rewards(params: Params, meta: RpcMeta) -> Result<Value, RpcError> {
    RPC_CALLS.inc();
    let client_id = require_auth(&meta, "claim_rewards")?;
    
    if !check_rate_limit("claim_rewards", &client_id) {
        return Err(RpcError::invalid_request("Rate limit exceeded"));
    }

    let (address,) = params.parse::<(String,)>()
        .map_err(|_| RpcError::invalid_params("Expected [address]"))?;

    let manager = crate::rewards::RewardManager::new(DATABASE.clone());
    
    match manager.claim_rewards(&address) {
        Ok(amount) => Ok(json!({
            "address": address,
            "claimed_amount": amount,
            "status": "success"
        })),
        Err(e) => Err(RpcError::invalid_request(&e.to_string()))
    }
}

