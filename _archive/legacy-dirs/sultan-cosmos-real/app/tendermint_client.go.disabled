package app

import (
    "context"
    "fmt"
    "time"

    rpchttp "github.com/cometbft/cometbft/rpc/client/http"
    ctypes "github.com/cometbft/cometbft/rpc/core/types"
    tmtypes "github.com/cometbft/cometbft/types"
)

// TendermintClient wraps CometBFT RPC client
type TendermintClient struct {
    client *rpchttp.HTTP
}

// NewTendermintClient creates a new Tendermint RPC client
func NewTendermintClient(nodeURL string) (*TendermintClient, error) {
    client, err := rpchttp.New(nodeURL, "/websocket")
    if err != nil {
        return nil, fmt.Errorf("failed to create tendermint client: %w", err)
    }
    
    // Start the client for websocket subscriptions
    if err := client.Start(); err != nil {
        return nil, fmt.Errorf("failed to start tendermint client: %w", err)
    }
    
    return &TendermintClient{
        client: client,
    }, nil
}

// GetStatus returns the node status
func (tc *TendermintClient) GetStatus(ctx context.Context) (*ctypes.ResultStatus, error) {
    return tc.client.Status(ctx)
}

// GetBlock fetches a block at a specific height
func (tc *TendermintClient) GetBlock(ctx context.Context, height *int64) (*ctypes.ResultBlock, error) {
    return tc.client.Block(ctx, height)
}

// GetLatestBlock fetches the latest block
func (tc *TendermintClient) GetLatestBlock(ctx context.Context) (*ctypes.ResultBlock, error) {
    return tc.client.Block(ctx, nil)
}

// BroadcastTx broadcasts a transaction
func (tc *TendermintClient) BroadcastTx(ctx context.Context, tx tmtypes.Tx) (*ctypes.ResultBroadcastTx, error) {
    return tc.client.BroadcastTxSync(ctx, tx)
}

// SubscribeToBlocks subscribes to new block events
func (tc *TendermintClient) SubscribeToBlocks(ctx context.Context) (<-chan ctypes.ResultEvent, error) {
    query := "tm.event='NewBlock'"
    out, err := tc.client.Subscribe(ctx, "sultan-client", query)
    if err != nil {
        return nil, fmt.Errorf("failed to subscribe to blocks: %w", err)
    }
    return out, nil
}

// SubscribeToTxs subscribes to new transaction events
func (tc *TendermintClient) SubscribeToTxs(ctx context.Context) (<-chan ctypes.ResultEvent, error) {
    query := "tm.event='Tx'"
    out, err := tc.client.Subscribe(ctx, "sultan-client", query)
    if err != nil {
        return nil, fmt.Errorf("failed to subscribe to transactions: %w", err)
    }
    return out, nil
}

// MonitorBlocks continuously monitors and processes new blocks
func (tc *TendermintClient) MonitorBlocks(ctx context.Context, handler func(*tmtypes.Block)) error {
    blockChan, err := tc.SubscribeToBlocks(ctx)
    if err != nil {
        return err
    }
    
    for {
        select {
        case <-ctx.Done():
            return ctx.Err()
        case event := <-blockChan:
            blockEvent, ok := event.Data.(tmtypes.EventDataNewBlock)
            if ok && blockEvent.Block != nil {
                handler(blockEvent.Block)
            }
        }
    }
}

// GetNetworkInfo returns network information
func (tc *TendermintClient) GetNetworkInfo(ctx context.Context) (*ctypes.ResultNetInfo, error) {
    return tc.client.NetInfo(ctx)
}

// GetConsensusState returns consensus state
func (tc *TendermintClient) GetConsensusState(ctx context.Context) (*ctypes.ResultConsensusState, error) {
    return tc.client.ConsensusState(ctx)
}

// GetValidators returns the validator set at a given height
func (tc *TendermintClient) GetValidators(ctx context.Context, height *int64, page, perPage *int) (*ctypes.ResultValidators, error) {
    return tc.client.Validators(ctx, height, page, perPage)
}

// Close closes the client connection
func (tc *TendermintClient) Close() error {
    return tc.client.Stop()
}

// TendermintNode represents a full Tendermint node integration
type TendermintNode struct {
    client    *TendermintClient
    p2p       *P2PNode
    ctx       context.Context
    cancel    context.CancelFunc
}

// NewTendermintNode creates a new Tendermint node with P2P
func NewTendermintNode(nodeURL string, p2pPort int, bootstrapPeers []string) (*TendermintNode, error) {
    ctx, cancel := context.WithCancel(context.Background())
    
    // Create Tendermint client
    client, err := NewTendermintClient(nodeURL)
    if err != nil {
        cancel()
        return nil, err
    }
    
    // Create P2P node
    p2pNode, err := NewP2PNode(ctx, p2pPort, bootstrapPeers)
    if err != nil {
        client.Close()
        cancel()
        return nil, err
    }
    
    node := &TendermintNode{
        client: client,
        p2p:    p2pNode,
        ctx:    ctx,
        cancel: cancel,
    }
    
    // Start monitoring blocks and broadcasting them via P2P
    go node.monitorAndBroadcast()
    
    return node, nil
}

// monitorAndBroadcast monitors Tendermint blocks and broadcasts via P2P
func (tn *TendermintNode) monitorAndBroadcast() {
    err := tn.client.MonitorBlocks(tn.ctx, func(block *tmtypes.Block) {
        fmt.Printf("New block received: Height=%d, Hash=%X\n", block.Height, block.Hash())
        
        // Serialize and broadcast via P2P
        blockBytes, err := block.Marshal()
        if err != nil {
            fmt.Printf("Failed to serialize block: %v\n", err)
            return
        }
        
        if err := tn.p2p.BroadcastBlock(blockBytes); err != nil {
            fmt.Printf("Failed to broadcast block via P2P: %v\n", err)
        } else {
            fmt.Printf("Block %d broadcast to %d peers\n", block.Height, len(tn.p2p.GetConnectedPeers()))
        }
    })
    
    if err != nil {
        fmt.Printf("Block monitoring error: %v\n", err)
    }
}

// GetStatus returns the combined status of Tendermint and P2P
func (tn *TendermintNode) GetStatus() (map[string]interface{}, error) {
    tmStatus, err := tn.client.GetStatus(context.Background())
    if err != nil {
        return nil, err
    }
    
    return map[string]interface{}{
        "tendermint": map[string]interface{}{
            "node_id":     tmStatus.NodeInfo.NodeID,
            "chain_id":    tmStatus.NodeInfo.Network,
            "block_height": tmStatus.SyncInfo.LatestBlockHeight,
            "catching_up": tmStatus.SyncInfo.CatchingUp,
        },
        "p2p": map[string]interface{}{
            "peer_id":        tn.p2p.host.ID().String(),
            "connected_peers": len(tn.p2p.GetConnectedPeers()),
            "listen_addrs":   tn.p2p.host.Addrs(),
        },
    }, nil
}

// Close shuts down the node
func (tn *TendermintNode) Close() error {
    tn.cancel()
    tn.p2p.Close()
    return tn.client.Close()
}
